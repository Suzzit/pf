<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./blog.css">
    <title>Lessons from Building a systemd-nspawn Container</title>
</head>

<body>

    <header>
        <h1>Lessons Learned from Building a systemd-nspawn Container</h1>
        <p>A practical journey through containers, networking, and Linux internals</p>
    </header>

    <div class="container">

        <article>
            <div class="meta">Section 1</div>
            <h2>You tried to build a container the honest way</h2>

            <p>You chose <code>systemd-nspawn</code>, not Docker. That matters:</p>
            <ul>
                <li>No daemon babysitting you</li>
                <li>No hidden NAT rules</li>
                <li>No “it just works” fairy dust</li>
            </ul>

            <p>You created a container root filesystem and tried to bootstrap Arch + nginx into it.</p>

            <p>Reality check: it immediately failed because your root partition was full. That wasn’t a container
                problem — that was disk accounting.</p>
        </article>

        <article>
            <div class="meta">Section 2</div>
            <h2>You hit real storage limits (and didn’t ignore them)</h2>

            <p>You discovered:</p>
            <ul>
                <li>No free space on /</li>
                <li>sda3 had ~98 GB, with ~5 GB realistically spare</li>
            </ul>

            <p>Core lessons:</p>
            <ul>
                <li>Filesystems ≠ partitions ≠ mount points</li>
                <li>Resizing requires shrinking filesystem → partition → new allocation</li>
                <li>Offline discipline is often mandatory</li>
            </ul>

            <p>You also learned why live USBs exist, why mounted partitions resist resizing, and why LVM exists to
                reduce friction.</p>
        </article>

        <article>
            <div class="meta">Section 3</div>
            <h2>You met systemd’s sharp edges</h2>

            <p><code>systemd-networkd</code> refused to start because it was masked.</p>

            <ul>
                <li>Masked ≠ stopped</li>
                <li>Masked = forbidden to run</li>
            </ul>

            <p>This was a deliberate desktop networking policy — not random failure.</p>
        </article>

        <article>
            <div class="meta">Section 4</div>
            <h2>Host vs container separation</h2>

            <p>You started <code>systemd-networkd</code> on the host while NetworkManager managed Wi-Fi.</p>

            <p>Result: network conflict.</p>

            <ul>
                <li>Host → NetworkManager</li>
                <li>Container → networkd + resolved</li>
            </ul>

            <p>This separation clarified system boundaries.</p>
        </article>

        <article>
            <div class="meta">Section 5</div>
            <h2>Manual container networking</h2>

            <p><code>--network-veth</code> only creates a link — configuration is manual.</p>

            <ul>
                <li>Enable networkd</li>
                <li>Create a <code>.network</code> config</li>
                <li>Request DHCP</li>
            </ul>

            <p>Only then did the container gain connectivity.</p>
        </article>

        <article>
            <div class="meta">Section 6</div>
            <h2>DNS debugging fundamentals</h2>

            <p>IP connectivity worked. Domains didn’t.</p>

            <ul>
                <li>Inspect <code>/etc/resolv.conf</code></li>
                <li>Enable <code>systemd-resolved</code></li>
                <li>Fix symlinks and restart services</li>
            </ul>

            <p>Name resolution restored full connectivity.</p>
        </article>

        <article>
            <div class="meta">Section 7</div>
            <h2>The finished system</h2>

            <p>You built a container with its own:</p>

            <ul>
                <li>Filesystem</li>
                <li>Init system</li>
                <li>Networking stack</li>
                <li>DNS resolver</li>
            </ul>

            <p>This clarified how abstractions hide complexity — and how Linux actually behaves.</p>
        </article>

        <article>
            <div class="meta">Reflection</div>
            <h2>The deeper outcome</h2>

            <ul>
                <li>Disk realities</li>
                <li>Service masking behavior</li>
                <li>Network boundaries</li>
                <li>DNS troubleshooting</li>
                <li>Operational ownership</li>
            </ul>

            <p>This wasn’t just setup — it was systems thinking in action.</p>
        </article>

    </div>

    <footer>
        © 2026 Container Learning Journal
    </footer>

</body>

</html>